// Copyright 2022 huija
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
	"fmt"
	"github.com/taouniverse/tao"
	"github.com/taouniverse/taogo/constant"
	"os"
	"runtime"
	"sort"
	"strings"
	"text/template"
)

// CheckDir before ExecuteTemplate
func CheckDir(dir, name string) (path string, err error) {
	if !strings.HasSuffix(dir, constant.PathSplit) {
		dir += constant.PathSplit
	}
	_, err = os.Stat(dir)
	if err != nil {
		return
	}
	path = dir + name + constant.PathSplit
	_, err = os.Stat(path)
	if err != nil {
		// create the target dir
		err = os.Mkdir(path, os.ModeDir|0755)
		if err != nil {
			return
		}
	} else {
		// check if the target dir was empty
		var readDir []os.DirEntry
		readDir, err = os.ReadDir(path)
		if err != nil {
			return
		}
		if len(readDir) > 0 {
			err = tao.NewError(tao.ParamInvalid, "%q was not empty", path)
			return
		}
	}
	// git init
	err = Init(path)
	return
}

// ExecuteTemplate to generate files
func ExecuteTemplate(templates, params map[string]string) error {
	for f, m := range templates {
		main, err := template.New(f).Funcs(templateFuncMap).Parse(strings.TrimPrefix(m, "\n"))
		if err != nil {
			return err
		}
		file, err := os.OpenFile(f, os.O_CREATE|os.O_RDWR, 0644)
		if err != nil {
			return err
		}
		err = main.Execute(file, params)
		if err != nil {
			return err
		}
		tao.Debugf("%s has been generated by taogo", f)
	}
	return nil
}

var templateFuncMap = template.FuncMap{
	"import":     importFunc,
	"firstChar":  firstChar,
	"toUpper":    strings.ToUpper,
	"title":      strings.Title,
	"modVersion": modVersion,
}

func importFunc(s string) (r string) {
	if s == "" {
		return
	}
	imports := strings.Split(s, constant.ParamSplit)
	sort.Strings(imports)
	for i := 0; i < len(imports); i++ {
		unitInfo := strings.Split(imports[i], constant.PathSplit)
		switch len(unitInfo) {
		case 1:
			if strings.HasPrefix(unitInfo[0], constant.DefaultUnitPrefix) {
				unitInfo = []string{constant.DefaultSite, constant.DefaultTeam, unitInfo[0]}
			}
		case 2:
			if strings.HasPrefix(unitInfo[1], constant.DefaultUnitPrefix) {
				unitInfo = []string{constant.DefaultSite, unitInfo[0], unitInfo[1]}
			}
		default:
		}
		r += fmt.Sprintf("%s\"%s\"", constant.ImportDaemon, strings.Join(unitInfo, constant.PathSplit))
		if i != len(imports)-1 {
			r += "\n\t"
		}
	}
	return
}

func firstChar(s string) (r string, err error) {
	if len(s) == 0 {
		return "", tao.NewError(tao.ParamInvalid, "empty string")
	}
	return s[0:1], nil
}

func modVersion(s string) (r string, err error) {
	if s == "" {
		s = runtime.Version()
	}
	goVersion := strings.Split(s, ".")
	if len(goVersion) <= 1 {
		return "", tao.NewError(tao.Unknown, "project: unknown go version %+v", goVersion)
	}
	return strings.Replace(goVersion[0]+"."+goVersion[1], "go1.", "go 1.", 1), nil
}
